---
layout: post
title: 时间复杂度与空间复杂度
categories: [算法]
tags: 算法
---

算法的执行效率是由内部因素与外部因素共同决定的：

* **内部因素：**执行算法所需要的时间、所需要的内存空间
* **外部因素：**输入的信息、计算机硬件、编译器的质量

通常，我们都将外部因素忽略不计，只通过内部因素来评估算法的效率，主要由以下两个复杂度进行评估：

* **时间复杂度：**执行算法所需要的时间，可以估算出程序对处理器的使用程度
* **空间复杂度：**执行算法所需要的存储空间，可以估算出程序对计算机内存的使用程度

# 时间复杂度

## 1、概念

一个算法的执行所耗费的时间，理论上是算不出来的，只有上机运行测试才能知道。但是我们不可能也没有必要对
每个算法都上机测试，只需要知道哪个算法花费时间多，哪个算法花费事件少就可以了。一个算法花费的时间与算法中
语句的执行次数成正比，哪个算法中语句执行次数多，它花费的时间就多。算法中语句的执行次数称为**时间频度**，记为$T(n)$。

在时间频度中，n为问题的规模，当n不断变化时，时间频度$T(n)$也会随之变化，但有时我们想知道其变化的规律，为此，引入**时间复杂度**
的概念。

什么是时间复杂度，算法中某个函数有n次基本操作重复执行，用$T(n)$表示，现在有某个辅助函数$f(n)$，使得当n趋近于无穷
大时，$T(n)/f(n)$的极限值是不为零的常数，则称$f(n)$是$T(n)$的同数量级函数。记做$T(n)=O(f(n))$，称$O(f(n))$为算法的
渐进时间复杂度，简称时间复杂度。通俗一点讲，所谓的时间复杂度就是找了一个同样曲线类型的函数$f(n)$来表示这个算法在n
不断变大时的趋势。

## 2、计算方法

算法的性能分为最坏情况（最大运行次数）、平均情况（期望运行次数）与最好情况（最小运行次数），在实际中，我们考量的是最坏运行情况。

（1）找出算法中的基本语句

算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。

（2）计算基本语句执行次数的数量级

只需要计算基本语句执行次数的数量级，意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有
低次幂和最高次幂的系数，这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。

（3）用大O记号表示算法的时间复杂度

将基本语句执行次数的数量级放入大O记号中。如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将
并列循环的时间复杂度相加。

## 3、举例

（1）时间复杂度$O(1)$
```java
int sum =0,n=100;			//执行一次
sum = (1+n)*n/2;			//执行一次
```

（2）时间复杂度$O(n)$
```java
for(int i=0;i<n;i++){
	System.out.println(i);		//执行n次
}
```

（3）时间复杂度$O(n^2)$
```java
for(int i=0;i<n;i++){
	for(int j=0;j<n;j++){
		System.out.println(j+i);	//执行n^2次
	}
}
```

```java
for(int i=0;i<n;i++){
	for(int j=i;j<n;j++){
		System.out.println(j+i);	//执行(n+1)*n/2次
	}
}
```

（4）时间复杂度$O(logn)$
```java
int i = 1,n=100;
while(i<n){
	i = i * 2;		//执行次数为x，2^x=n，即x=log2n
}
```

常用的时间复杂度所耗费的事件从小到大依次是：

$$O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$$

# 空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括
存储算法本身所占用的存储空间、算法的输入数据所占用的存储空间和算法在运行过程中临时占用的存储空间。

对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致
占用较多的存储空间；反之，追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。
因此，设计一个算法时，要综合考虑算法的各项性能。